% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spark.R
\name{spark}
\alias{spark}
\title{SParsifying mARK-recapture Data}
\usage{
spark(indata = NULL, infile = NULL, informat = "spark",
  outformat = "spark", k = 5, datatype = "recaptures", compress = FALSE,
  ragged = TRUE, collapse = FALSE, ...)
}
\arguments{
\item{indata}{Input data set with complete capture histories. Either \code{indata} or \code{infile} must be specified.}

\item{infile}{Path to file containing input data set with complete capture histories. Either \code{indata} or \code{infile} must be specified.}

\item{informat}{Format of input data set. Currently available formats include: mark, marked, and spark, the internal data format. See details for further description.}

\item{outformat}{Format of output data set. Currently available formats include: mark, marked, or spark. See Details for further description.}

\item{k}{Truncation limit. See Details for further description.}

\item{datatype}{Either "recaptures" for recaptures only data or "livedead" for recaptures and recovery data.}

\item{compress}{If TRUE then the data will be compressed by converting histories from length \eqn{k} to length \eqn{T}.}

\item{ragged}{Creates ragged capture histories (see Details).}

\item{collapse}{If TRUE then unique histories are identified and counted. This will not work with individual covariates.}

\item{...}{Further parameters passed directly to the data conversion functions.}
}
\value{
An output data set in the specified format inlcuding the truncated capture histories.
}
\description{
Primary function for creating truncated capture histories for CJS based mark-recapture models. This function
handles the input and output of data and for the user and coordinates the other functions that do the main work.
}
\details{
\strong{Truncation}

The objective of \code{spark} is to reduce the computation time of complex mark-recapture models by
truncating the individual capture histories. Truncation occurs in two steps. First, a new capture history
is created for each release of an individual. Second, these capture histories are truncated by including the
events up to the first recapture to a maximum of \eqn{k} occasions where \eqn{k} is the user defined truncation
factor. Suppose for example that \eqn{T=10} and consider the simple CJS capture history \eqn{1010000001} and we
set \eqn{k=3}. The truncated data set generated by \code{spark} will contain two histories for this individual:
\eqn{101.......} and \eqn{001000....}. The \code{.} notation in these histories is borrowed from Program MARK and
indicates that the individual is no longer available for capture. The first history indicates that the individual
was first released on occasion 1 and next recaptured on occasion 3. The second indicates that the individual ws
released on occasion 3 and not recaptured within the next \code{k=3} occasions. Note that the recapture on the
final occasion is ignored. While this reduces the amount of information -- we are essentially ignoring the fact that
this individual must have been alive for the entire experiment -- the computational expense can be greatly reduced
and the loss of precision may be small if individuals are short lived and/or the capture probability is high so that
the expected time to recapture given that an individual is recaptured is low.

A clearer example of the computational gain comes when the same method is applied to the multi-state model. Suppose that
the above example is expanded to include 26 possible states on each capture labelled with the latin alphabet. Consider
the history \eqn{A0B000000C}. To compute the full likelihood for this individual we need to allow for all possible
transitions between states on the 7 occasions when the individual was not captured. This is an expensive calculation
even with efficient matrix calculations based on hidden Markov models. Truncating with \eqn{k=3} the
histories are \eqn{A0B.......} and \eqn{00B000....} and we need only model the possible transitions over 4 occasions. The
computational savings increase as \eqn{T} increases.

A simple example is provided in \code{demo(cjs_demo_dippers_1)}.

\strong{Compress}

By default the capture histories in the new data set will have the same length as the capture histories in the
original data set. However, these histories have at most \eqn{k+1} elements not equal to '.'. The extra elements
can be removed by setting \code{compress = TRUE}. In this case, the capture histories will be stored as vectors
of length \code{k+1} and the variable \code{release} is used to track the occasion on which the capture history starts.
For example, if \code{compress = TRUE} and \code{k=3} then the capture history \eqn{A0B000000C} considered above creates
two capture histories \eqn{A0B.} and \eqn{B000} with the release values 1 and 3, respectively. In Program MARK
groups can be defined based on the value of \code{release}. The correct time structure for the
parameters can then be obtained by specifying the begin time for each group.

This is illustrated in \code{demo(cjs_demo_dippers_2)}.

\strong{Ragged}

There are some disadvantages to compressing the data in this way. One is that the time structure is somewhat
corrupted so that, for example, it is no longer to allow time intervals of different length. The second is
that Program MARK (and possibly other software) will introduce extra parameters are introduced when a release occurs on the final \eqn{k} occasions. As an example,
suppose that \eqn{T=5} and we observe the history \eqn{00100}. If \eqn{k=3} and \code{compress=TRUE} then the
truncated history generated by this individual is \eqn{100.} with a release value of 3. This makes it appear
to Program MARK that the original capture history was \eqn{00100.} and so MARK will introduce a fifth survival and
fifth capture probability into the set of parameters, even though these parameters are entirely unestimable (even with
constraints).

This can be avoided by setting \code{ragged=TRUE}. When \code{ragged=TRUE} the histories are padded with 0s before
the releaase so that the number of occasions is not increased. For example, the history above would be recoded as
\eqn{0100} with an initial value of 2 indicating that the capture history starts on the second occasion even though
the individual was not released until the third occasion.

When \code{ragged} is \code{FALSE} then the vectors \code{inital} and \code{release} within the \code{spark} data
object will be identical. When \code{ragged} is \code{FALSE} the elements of these vectors will differ for
individuals captured within the final \eqn{k-1} occasions.

The default behaviour is to set \code{ragged=TRUE} whenever \code{compress=TRUE}. This is illustrated in
\code{cjs_demo_dippers_3}.

\strong{Data Formats}

The package currently supports three (well, really two) output data formats:
\enumerate{
\item \code{spark}: the internal data format consists of a list the following elements
\itemize{
\item chmat: matrix of capture histories (individuals in rows and occasions in columns)
\item freq: vector of frequencies associated with each capture history
\item other: matrix of covariates or other variables supplied by the user
\item release: vector of release times associated with each history in chmat
\item initial: vector of initial times associated with each history in chmat
}
\item \code{marked}: a data frame as used in the functions \code{\link[RMark]{process.data}} from both \code{RMark}
and \code{marked}.
\item \code{mark}: an alias for the \code{marked} format which adds functionality for reading directly from INP files.
}

Data may be provided to \code{spark} in either of the above formats. Additionally, \code{spark} can read data
directly from input files for Program MARK when using the \code{mark} format.
}
\examples{

## Truncating the dipper data
library(RMark)
data(dipper)
dipper.trunc = spark(dipper,informat="marked",outformat="marked",k=3)
}

