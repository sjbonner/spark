#' SParsifying mARK-recapture Data
#'
#' Primary function for creating truncated capture histories for CJS based mark-recapture models. This function
#' handles the input and output of data and for the user and coordinates the other functions that do the main work.
#'
#' \strong{Truncation}
#'
#' The objective of \code{spark} is to reduce the computation time of complex mark-recapture models by
#' truncating the individual capture histories. Truncation occurs in two steps. First, a new capture history
#' is created for each release of an individual. Second, these capture histories are truncated by including the
#' events up to the first recapture to a maximum of \eqn{k} occasions where \eqn{k} is the user defined truncation
#' factor. Suppose for example that \eqn{T=10} and consider the simple CJS capture history \eqn{1010000001} and we 
#' set \eqn{k=3}. The truncated data set generated by \code{spark} will contain two histories for this individual:
#' \eqn{101.......} and \eqn{001000....}. The \code{.} notation in these histories is borrowed from Program MARK and
#' indicates that the individual is no longer available for capture. The first history indicates that the individual
#' was first released on occasion 1 and next recaptured on occasion 3. The second indicates that the individual ws
#' released on occasion 3 and not recaptured within the next \code{k=3} occasions. Note that the recapture on the 
#' final occasion is ignored. While this reduces the amount of information -- we are essentially ignoring the fact that
#' this individual must have been alive for the entire experiment -- the computational expense can be greatly reduced
#' and the loss of precision may be small if individuals are short lived and/or the capture probability is high so that
#' the expected time to recapture given that an individual is recaptured is low.
#' 
#' A clearer example of the computational gain comes when the same method is applied to the multi-state model. Suppose that
#' the above example is expanded to include 26 possible states on each capture labelled with the latin alphabet. Consider
#' the history \eqn{A0B000000C}. To compute the full likelihood for this individual we need to allow for all possible
#' transitions between states on the 7 occasions when the individual was not captured. This is an expensive calculation
#' even with efficient matrix calculations based on hidden Markov models. Truncating with \eqn{k=3} the 
#' histories are \eqn{A0B.......} and \eqn{00B000....} and we need only model the possible transitions over 4 occasions. The
#' computational savings increase as \eqn{T} increases. 
#'
#' \strong{Data Formats}
#'
#' The package currently supports three (well, really two) output data formats:
#' \enumerate{
#' \item \code{spark|: the internal data format consists of a list the following elements
#' \itemize{
#' \item chmat: matrix of capture histories (individuals in rows and occasions in columns)
#' \item freq: vector of frequencies associated with each capture history
#' \item other: matrix of covariates or other variables supplied by the user
#' \item release: vector of release times associated with each history in chmat
#' \item initial: vector of initial times associated with each history in chmat
#' }
#' \item \code{marked}: a data frame as used in the functions \link[RMark]{process.data} from both \code{RMark} 
#' and \code{marked}.
#' \item \code{mark}: an alias for the \code{marked} format.
#' }
#'
#' Data may be provided to \code{spark} in either of the above formats. Additionally, \code{spark} can read data
#' directly from input files for Program MARK using \code{\link{mark2spark}}.
#'
#' \strong{Ragged}
#'
#' If \code{ragged==TRUE} then extra 0's are added to the start of capture histories when the release occurs
#' within the final \eqn{k-1} occasions. This avoids creating extra parameters in some software packages that are hypothetically associated
#' with capture occasions after the final occasion.
#'
#' As an example, suppose that you have data from a study with 4 capture occasion and
#' are fitting a fully time dependent CJS model so that there are 3 survival and 3 capture probabilities. Consider the history 0010 and suppose that $k=3$.
#' If \code{ragged==FALSE} then the truncated history associated with the release at time 3 will be encoded as \code{10..} with
#' both the \code{initial} and \code{release} times for this individual set to 3.
#' Program MARK, for example, will then attempt to estimate 5 survival and 5 capture probabilties, although the final two probabilities
#' are unestimable. If \code{ragged==FALSE} then the history is recoded as \code{0010} with the \code{initial} and \code{release}
#' times set to 1 and 3 respectively.
#'
#' When \code{ragged} is \code{FALSE} then the vectors \code{inital} and \code{release} within the \code{spark} data
#' object will be identical. When \code{ragged} is \code{FALSE} the elements of these vectors will differ for
#' individuals captured within the final \eqn{k-1} occasions.
#'
#' The demos \code{cjs_demo_dippers_1} and \code{cjs_demo_dippers_2} illustrate the differences between these approaches.
#
#' @param indata Input data set with complete capture histories. Either \code{indata} or \code{infile} must be specified.
#' @param infile Path to file containing input data set with complete capture histories. Either \code{indata} or \code{infile} must be specified.
#' @param informat Format of input data set. Currently available formats include: mark, marked, and spark, the internal data format. See details for further description.
#' @param outfile Path to file for writing output data set. If NULL then the modified data will be returned but not written to a file.
#' @param outformat Format of output data set. Currently available formats include: mark, marked, or spark. See Details for further description.
#' @param k Truncation limit. See Details for further description.
#' @param ragged If TRUE then within k occasions of the final occasion will be shortened. Otherwise, extra 0s will be added to the beginning of the capture history. See Details for further description.
#' @param collapse If TRUE then unique histories are identified and counted. This will not work with individual covariates.
#' @param ... Further parameters passed directly to the data conversion functions.
#'
#' @return An output data set in the specified format inlcuding the truncated capture histories.
#' @export
#'
##' @examples
##'
##' ## Truncating the dipper data
##' library(RMark)
##' dipper.trunc <- spark(dipper,informat="marked",outformat="marked",k=3)

spark <- function(indata = NULL,
                  infile = NULL,
                  informat = "spark",
                  outfile = NULL,
                  outformat = "spark",
                  k = 5,
                  ragged = FALSE,
                  collapse = FALSE,
                  ...) {
  ## Format input data if necessary
  if (informat == "mark")
    indata <- mark2spark(indata, infile, ...)
  else if (informat == "marked")
    indata <- marked2spark(indata, infile, ...)
  else if (informat != "spark")
    stop("Sorry, I do not recognize that informat.\n")

  ## Remove histories that do not contribute to likelihood
  first <- apply(indata$chmat, 1, function(w)
    min(which(w > 0)))
  invalid <- which(first == ncol(indata$chmat))

  if (length(invalid) > 0) {
    warning(
      "Removing ",
      length(invalid),
      " individuals first released on occasion ",
      ncol(indata$chmat),
      ".\n"
    )

    indata$chmat <- indata$chmat[-invalid, ]
    indata$freq <- indata$freq[-invalid]

    indata$other <- indata$other[-invalid, , drop = FALSE]
  }

  ## Check value of k
  if (k > (ncol(indata$chmat) - 1)) {
    k <- ncol(indata$chmat) - 1
    warning(
      "The value of k must be less than the number of capture occasions. Setting k=",
      k,
      ". This will reproduce the full model with no truncation.\n"
    )
  }

  ## Truncate capture histories
  outdata <-
    truncateCH(indata,
               k = k,
               ragged = ragged,
               collapse = collapse)

  ## Format output data if necessary
  if (outformat == "mark")
    return(spark2mark(outdata, outfile))
  else if (outformat == "marked")
    return(spark2marked(outdata, outfile))
  else if (outformat == "list")
    return(spark2list(outdata, outfile))
  else if (outformat == "bugs")
    return(spark2bugs(outdata, outfile))
  else if (outformat != "spark")
    stop("Sorry, I do not recognize that outformat.\n")
  else
    return(outdata)
}

truncateCH1 <- function(chin, k, ragged = FALSE) {
  ## Creates truncated records for a single individual

  ## Useful constants
  nocc <- length(chin)                # Number of occasions

  ## Identify captures
  capture <- which(chin > 0)
  ncapture <- length(capture)

  ## Identify times of release
  if (capture[ncapture] == nocc)
    ## Individual was last captured on final occasion
    release <- capture[-ncapture]
  else
    ## Individual was last captured before final occasion
    release <- capture
  nrelease <- length(release)

  ## Identify times of recapture (within k occasions)
  if (capture[ncapture] == nocc)
    ## Individual was last captured on final occasion
    recapture <- ifelse(capture[-1] - release <= k, capture[-1], -1)
  else
    ## Individual was last captured before final occasion
    recapture <-
    c(ifelse(capture[-1] - release[-nrelease] <= k, capture[-1], -1), -1)

  ## Initialize output
  chout <- matrix(".", nrelease, k + 1)

  ## Compute padding values if requested
  if (ragged)
    pad <- pmax(k + release - nocc, 0)
  else
    pad <- rep(0, nrelease)

  ## Add release states in first column
  chout[cbind(1:nrelease, pad + 1)] <- chin[release]

  ## Create records for all but the final release
  for (j in 1:nrelease) {
    if (ragged)
      ## Add padding
      if (pad[j] > 0)
        chout[j, 1:pad[j]] <- 0

      if (recapture[j] < 0) {
        ## Individual was not recaptured within k occasions
        chout[j, (2 + pad[j]):(min(k + 1, nocc - release[j] + 1 + pad[j]))] <-
          0
      }
      else{
        ## Compute difference between release and recapture
        d <- recapture[j] - release[j]

        if (d > 1)
          ## Individual was not captured on subsequent occasion
          chout[j, pad[j] + (2:d)] <- 0

        ## Recapture
        chout[j, d + 1 + pad[j]] <- chin[recapture[j]]
      }
  }

  ## Identify time of initial capture occasion in truncated history
  if (ragged)
    initial <- release - pad
  else
    initial <- release


  ## Return new records
  list(
    nrelease = nrelease,
    ch = chout,
    release = release,
    initial = initial,
    recapture = recapture
  )
}


truncateCH <- function(indata,
                       k = NULL,
                       ragged = FALSE,
                       collapse = FALSE) {
  if (is.null(k))
    stop("You must specify a value for the truncation parameter, k.\n")


  ## Truncate capture histories
  chnew.list <-
    apply(indata$chmat,
          1,
          truncateCH1,
          k = k,
          ragged = ragged)

  ## Stack new capture histories
  chmat <- do.call("rbind", sapply(chnew.list, "[[", "ch"))

  ## Extract release and recapture times and initial times
  release <- unlist(sapply(chnew.list, "[[", "release"))
  recapture <- unlist(sapply(chnew.list, "[[", "recapture"))
  initial <- unlist(sapply(chnew.list, "[[", "initial"))

  ## Create individual mapping vector
  nrelease <- sapply(chnew.list, "[[", "nrelease")
  ind <- rep(1:nrow(indata$chmat), nrelease)

  ## Add useful rownames
  if (is.null(rownames(indata$chmat)))
    rownames(chmat) <- paste(ind, release, sep = ".")
  else
    rownames(chmat) <-
    paste(rep(rownames(indata$chmat), nrelease), release, sep = ".")

  ## Create output object
  if (collapse) {
    ## Aggregate data if requested
    if (!is.null(indata$other))
      stop("Aggregation is not currently supported when extra covariates are supplied.\n")

    df = data.frame(
      chmat = chmat,
      release = release,
      initial = initial,
      recapture = recapture,
      freq = indata$freq[ind],
      stringsAsFactors = FALSE
    )

    vars = c(paste0("chmat.", 0:k + 1), "release", "initial", "recapture")

    output.tmp = df %>%
      group_by_(.dots = vars) %>%
      tally(wt = freq)

    output = list(
      chmat = output.tmp[, paste0("chmat.", 0:k + 1)],
      release = output.tmp$release,
      initial = output.tmp$initial,
      recapture = output.tmp$recapture,
      freq = output.tmp$n,
      aggregated = TRUE
    )
  }
  else{
    output <- list(
      chmat = chmat,
      nrelease = length(release),
      release = release,
      initial = initial,
      recapture = recapture,
      ind = ind,
      freq = indata$freq,
      other = indata$other,
      aggregated = FALSE
    )
  }

  class(output) <- "spark"

  ## Return output
  output
}
